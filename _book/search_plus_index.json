{"./":{"url":"./","title":"前言","keywords":"","body":"前言 Hi！这里是我的网站。 我会定时地在这里进行发稿，欢迎持续关注哟~ 我还有个知乎专栏，会定时同步发布我的稿子：我是一只猿。 "},"pylearning/":{"url":"pylearning/","title":"Python学习笔记","keywords":"","body":"Python学习笔记 这是我编写的Python学习笔记，妥妥的教程~ 分为基础语法，神奇爬虫，看数据，自己办公四大类，有时还会更新随记。目前正在更新中~ 欢迎关注，Joinsodome期待你的支持！ "},"pylearning/basic/":{"url":"pylearning/basic/","title":"1.基础语法","keywords":"","body":"1.基础语法 这是Python学习笔记的基础语法。 在这章中，我们将了解Python，学习Python，编出漂亮的脚本。 由于自身的功底，保证不含糊，让你变成小小的Pythonner。 "},"pylearning/basic/1.html":{"url":"pylearning/basic/1.html","title":"1.迈出第一步","keywords":"","body":"Python学习笔记（1）——迈出第一步 前面有提到我的本职Python。 那么今天就带大家一起研究这个当下仅次于Java的超级编程。 1.安装 安装是肯定的，不然你以为它自带呀。 提示：截止到发文，Python最新是3.9.6，且本文的蓝奏云地址为3.8.0！ 如何安装呢？ 打开你的浏览器，定位到地址栏（前面全是废话），访问： https://www.python.org/ 点击Downloads-->你的操作系统，如这里是Windows： 选择要下载的版本，如这里是3.8.1： executable installer意思是可执行安装文件，即.exe，embeddable zip file是可嵌入ZIP文件（没有PIP！），web-based installer是基于 Web 的安装程序（慢的想吐！！！！）。综上所述，只有executable installer最靠谱。 如果打不开，可以用如下的链接：（密码：py38） Python 3.8.0 32位 下载好后，双击安装。（演示安装包目前只找到3.8.0的了） 接下来就是如下页面： 下一步： 到这一步，点击Install就可以安装啦。 MacOS类似。 2.测试 win+r输入cmd回车，输入： python -V # V必须是大写！ 如果输出： Python %PYVER% 就表明你成功啦！ 如果输出： 'python' 不是内部或外部命令，也不是可运行的程序或批处理文件。 那么看一看前面的”Add Python 3.8 to PATH“有没有勾上，或者python有没有输成pyhton（我就是这样入坑的）。 如果没有，控制面板-->系统-->高级系统设置-->环境变量-->系统变量-->Path-->输入“;Python的安装路径;”-->确定x3。 完成后重启，我就不信...... 3.瑞士军刀也需要刀柄 Python也需要一个编辑器，但他自带的IDLE是世界上最好用的编辑器。（倒数......） 且IDLE由Tk编写，Tk有多丑就不说了，看图吧。 这里就推荐两个： Pycharm 和VSCode。 第一个推荐的，绝对是Pycharm！ Pycharm由JetBrains编写，因此绝对一个字——帅。 同时还能管理Git，甚至还能收起代码，是不是很棒！ 其次就是VSCode！ 由于他爸爸Microsoft的培养，简直就是麻雀虽小五脏齐全！ 还可以安装插件，因此几乎支持世界上所有编程语言！ 此外还有Subline Text等等，就不说啦。 本教程如没有特殊说明，以Pycharm作为编辑器。 4.正式开始吧 现在正式开始吧！ win+r输入cmd回车，输入python回车，再输入： print('Hello!') 回车将输出： Hello! 嘿，就算没干什么高级的，这也够惊艳了。 5.现在完成一个脚本吧 别的不说，现在我们就开始弄脚本。 现在新建一个文件叫Hello.py，双击。如果正常的话应该会打开Pycharm。 在右侧输入： if __name__ == '__main__': print('Hello!') 此时应该是这样的： 点击这里的绿三角，再点击修改运行配置。 直接点击确定。 再点击上面的绿三角。 下面会出现和环节4一样的运行结果，不一样的是会返回运行代码，正常为0。 if是判断，name是特殊变量。这些以后再说。 好啦，这就是本期的内容！ 散会~ "},"pylearning/basic/2.html":{"url":"pylearning/basic/2.html","title":"2.你不得不知道的小常识","keywords":"","body":"Python学习笔记（2）——你不得不知道的小常识 接上次，这次来说一下你不得不知道的小常识。 上一弹详见：Python学习笔记（1）——迈出第一步 1.变量&常量 重要性：★★★★★ 比如，小明失忆了，连自己叫啥都忘了，这时妈妈拿过来一个盒子，抽出盒子里的纸条，一看，是“小明”。这是常量。 再比如，小亮原来的名字“狗粮”太搞笑了，然后改完户籍后，把自己的盒子里名字改成“小亮”。这是变量。 常量的赋值如下： XIAOMING = '小明' 变量的赋值如下： xiaoliang = '小亮' 常量不可修改，变量可修改。 注意！常量还是可以修改的，只不过“不可修改”是Python的公约。可是你要改，谁都没办法。如下图，在二次赋值时，Python完全没有报错。 变量和常量可以用在代码的天涯海角。 以下代码不用理解，看懂就行。 c = '小明' # 给列表添加\"小明\"。 u = ['小亮','小青'] u.append(c) # 这里用到了变量。 print(u) # 这里也用到了变量。 ''' ['小亮','小青','小明'] ''' 2.缩进 重要性：★★ 第二重要的就是缩进，因为凡是学过任何一门著名编程（C，C++，C#，Java......（此处省略无数种））的盆友们，都知道代码是这样的： public class Kzx { public static void main(String[] args) { // 一大堆乱七八糟的代码...... } } 是这样的： package kzx import \"fmt\" func main() { // 一大堆乱七八糟的代码...... } 是这样的......（此处省略1000字） 总的来说，他们都用{}包裹代码。所以还可以这样： public class Kzx { public static void main(String[] args) { // 一大堆乱七八糟的代码...... } } 而有点技术水平的，Github上的用Python编写的代码下下来一看，都是这样的： def main(): # 开头的第一行代码...... # 一大堆乱七八糟的代码...... if __name__ == '__main__': main() 那么如果这样： def main(): # 开头的第一行代码...... # 一大堆乱七八糟的代码...... if __name__ == '__main__': main() 不仅代码读起来要人命，还会： File \"xxx\",line 2 # 开头的第一行代码...... ^ IndentationError: expected an indented block 那些空格，编程界学名为缩进。 Python的缩进是4个空格。 键盘上的TAB键也可以。 但是空格和TAB不能混用。 比如说这样： 以上内容会输出以下结果： File \"xxx\",line 3 xxxxx...... ^ IndentationError: unindent does not match any outer indentation level 如上可见，缩进多重要。 但世界上所有编辑Python脚本的编辑器，都可以自动缩进。 所以，不用太太担心。 3.PEP 重要性：★★★★ 写出的代码肯定得好看呀。就像下面两段代码一样。 print(1) # 打印出1。 print(2) # 打印出2。 # -------------------------- print(1);print(2) 以上第2段代码用了分号。虽然可以这样做，但这是PEP不推崇的。 Python的PEP就是来教大家如何写出好看的代码。 如果你想看到更详细的，请备上翻译器，查阅PEP8英文版指南。 只要简单做到如下： 1.把代码限制到每行最少79个字符。 如： print(1,2,'此处省略70字……') # 应改为： print(1) print(2) # ...... 2.在运算符前中断，而不要在之后。 官方对此的说法是： To solve this readability problem, mathematicians and their publishers follow the opposite convention. Donald Knuth explains the traditional rule in hisComputers and Typesetting series: \"Although formulas within a paragraph always break after binary operations and relations, displayed formulas always break before binary operations\". 翻译为： 为了解决这个可读性问题，数学家和他们的出版商遵循了相反的惯例。Donald Knuth在他的《计算机和排版》系列中解释了这个传统规则：“虽然段落中的公式总是在二元运算和关系之后中断，但显示的公式总是在二元运算之前中断”。 如： c = [1, 2, 3] # 应改为: c = [1 ,2 ,3] 3.导入模块时，最好不要一行导入多个。但是在使用from...import...语句时可以，且在导入好多模块的时候可以。 如： import os,time # 应改为： import os import time # --------------- import os import time import easygui import numpy # ...... # 应改为： import os,time,easygui,numpy,...... # --------------- from tkinter import Button from tkinter import Canvas # ...... # 太残忍了，应改为： from tkinter imort Button,Canvas,...... 以上必须要牢记，因为这是最基本的了！ 好啦，这就是本期的内容！ 散会~ "},"pylearning/basic/3.html":{"url":"pylearning/basic/3.html","title":"3.人机交互","keywords":"","body":"Python学习笔记（3）——人机交互 接上回，这次来说说人机交互。 上一弹详见：Python学习笔记（2）——你不得不知道的小常识 额，分割线，我居然今天才发现这功能。真笨。(～￣(OO)￣)ブ 1.概念：IO 英语六级的都知道，IO是Input/Output的缩写，翻译为“输入与输出”。 就比如，我现在在编“Python学习笔记”，这叫输入（Input）；屏幕把我写的显示出来，这叫输出（Output）。 再比如，我用Python读取文档，这叫输入（Input）；再用Python把文档打印到屏幕上，这叫输出（Output）。 文档的IO我们后面讲。 一般IO分同步和异步。 同步（单线程）指一步一步来。比如你来点餐，我做饭，完成后给你，然后继续招待其他顾客。 异步（多线程）指一次多步，一次多人。比如你来点餐，我做饭，小A继续招待其他顾客，小B来了，小A做饭，小C继续招待其他顾客…… 但异步IO虽然可大量节省时间，但过于麻烦，因此本文为同步IO概念。 比如，就算有很简单的Asyncio，这样的代码： import asyncio async def hi(): print('Hi!') await asyncio.sleep(0.5) print('Hello!') async def bye(): print('Byebye!') await asyncio.sleep(0.5) print('Good bye!') async def system(): await asyncio.gather(hi(),bye()) if __name__ == '__main__': asyncio.run(system()) 你会写么？ 所以，先闭嘴吧，我们后面讲。(⊙x⊙;) 2.实现IO吧 人机交互就是一种IO。会玩人机交互这种基本IO，才能正式开始写完美的脚本。 为什么？ 因为你看，实现学生信息管理——SQLite IO，实现输入——人机交互IO，实现考勤——Excel IO…… 那现在，我们就开始写人机交互代码吧。 2.1.输出（Output） 首先，输出可是基本功。 还记得我们第一弹写的代码吗？（第一弹详见：Python学习笔记（1）——迈出第一步） if __name__ == '__main__': print('Hello!') 其中有这么一个函数： 函数的整体概念我们后面讲。 print('Hello!') 这个print(xxx)就是输出的函数。 print有一个可选参数： file=sys.stdout sys.stdout意思为终端屏幕，因此print默认意思为把文字打印到屏幕上。 你也可以尝试把file指向open()，这样就可以把数据写入文档。 可别以为print太简单了，在一个我还没完成的166行的代码里，print的数量就高达32个！ print简直是每一行代码里都要有的角色！ 比如： print('Hi!') print('Hello!') print('This is Example.') print('这是个测试。') 现在来做个测试： 用Python输出“你好呀！”，“喜欢我吗？”，“我是小明”，“我就是喜欢你！么么哒~”。 效果如下： 你好呀！ 喜欢我吗？ 我是小明 我就是喜欢你！么么哒~ 把写好的代码推到“PyLearningExample”仓库，具体方法见README。实战号：u3uprint。 2.2.输入（Input） 其次，输入也很重要。比如，要想获取用户在想什么，你就得让他输入。 input是输入的函数，具体用法如下： input('我是提示语句') 但实际运用中，要把input存入变量中。否则，input将无法存放用户的数据！ 我是变量 = input('我是提示语句') Python允许中文名变量。建议开发中不要运用，这里仅仅是演示罢了。 比如，游戏A必须实名，那小明怎么输入名字呢？ name = input('请输入名字：') ''' 请输入名字：（输入：小明） ''' 由于名字存入了变量name，因此可以轻松调取： print('尊敬的%s，您好！'%name) ''' 尊敬的小明，您好！ ''' 现在来做个测试： 获取用户的年龄（提示语句为：“请输入你的年龄：”），并打印出来。 效果如下： 请输入你的年龄：（输入：3） 3 把写好的代码推到“PyLearningExample”仓库，具体方法见README。实战号：u3uinput。 好啦，这就是本期的内容！ 散会~ "},"pylearning/basic/4.html":{"url":"pylearning/basic/4.html","title":"4.Asyncio","keywords":"","body":"Python学习笔记（4）——Asyncio 这次超纲了，部分内容我们没有学过，所以看看就行了。 hahaha，我这次破一次例，开始教大家学异步（携程）。 由于异步IO要求很高的水平，所以我们后面讲。要看同步IO（人机交互），请移步：Python学习笔记（3）——人机交互 1.概念：多线程、多进程、携程 事实上，在异步操作的过程中，多线程与多进程才是王道。 有了它们，甚至可以一秒干完10件事。 要是一个线程堵塞，没事，咱可以换。 所以这样看，多线程与多进程确实很棒。 更换线程 但是，它们很麻烦。 一个print就要10行，震惊了吧？ 而且还涉及Lock，想一想你会吗？ 而Python 3.4终于迎来了异步的又一选择。作为新引入的模块，Asyncio这种异步携程编写简单，易上手，迎来了更多人的欢迎。 2.Asyncio是怎么设计的 Asyncio其实是单线程。 那有的小伙伴肯定会说： 那还叫异步吗？这是异步呀，异步！！单线程怎么行！！ 但Asyncio的设计方式是“协作多任务”（Cooperative multitasking），即携程。也就是说，A在处理完一些任务后，放出执行权，B干其他的任务，弄完后，再放出执行权，以此类推，再回到A的手上。 因此，Asyncio少了多线程与多进程的各种麻烦操作，简单易上手。 3.那还等什么？！开始呀！？ “好好好好，开始开始开始......”（熬夜继续编） 注意！该写法只适用于Python 3.7以上！ 首先是导入，不然简直是没法用。 import asyncio 紧接着，设定两个任务，这里需要用到函数（也就是超纲的地方……）。不一样的是要标注async。（注意要放到main里，不能放到任何嵌套函数下） async def one(): # 你的代码...... async def two(): # 你的代码...... 接下来，设定放出执行权的地方。也就是用await语句。 比如，one里面： print(1) await asyncio.sleep(0) # 0的意思是不等待，直接放出执行权。 print(2) two里面： print('a') await asyncio.sleep(0) print('b') 然后，再输入：（注意要放到main里，不能放到任何嵌套函数下） async def system(): await asyncio.gather(one(),two()) asyncio.run(system()) 完成后，就应该是这样子： import asyncio async def one(): print(1) await asyncio.sleep(0) # 0的意思是不等待，直接放出执行权。 print(2) async def two(): print('a') await asyncio.sleep(0) print('b') async def system(): await asyncio.gather(one(),two()) asyncio.run(system()) 我们想他应该这样运行： 1 2 a b 但在运行时，他却这样运行： 速度倒是变快了。 怎么回事呢？ 其实，它先打印出1，再因为await转让执行权，打印出a，再因为await转让执行权，打印出2，再因为await转让执行权，打印出b。 就是这么简单。 当然了，同学们后面也可以研究多线程与多进程，但是Asyncio已经很强大了。 好啦，这就是本期的内容！ 散会~ "},"pylearning/basic/5.html":{"url":"pylearning/basic/5.html","title":"5.类型","keywords":"","body":"Python学习笔记（5）——类型 在看完本文后，请看后面的更新。 接上次（应该是上上次……），这次抛开“不正经”，继续给大家介绍小知识。 上一弹详见：Python学习笔记（4）——Asyncio 1.我们以前写的都是甚么鬼 大家是不是都很好奇之前我们在学习Python的时候，为什么有时候print不带引号，有时候带： 红色代表没带，绿色代表带了。 那么没带和带有什么区别吗？ 当然有啦。 在示例1中，红色箭头指向的是整数（Int，在SQLite中叫Integer），可以用运算符四法宝（+-*/）计算。而绿色指向的是字符串（Str，在其它编程语言中叫String），可以用+和*计算。 更多运算符将在Python学习笔记（6）中找到，尽请期待。 在示例2中，红色箭头指向的是变量（Value）。变量就不用我多说了吧，你在Python学习笔记（2）——你不得不知道的小常识里就能找到。 那么，我们今天就开始认识他们，以及其他小玩意儿。 2.正式开始认识 值得一提的是，在交互式python中输入各种类型的数据，都能得到回应。而巧妙运用运算符四法宝，还能更酷。 2.1.整数（下文简称Int） 正如前面所说，运算符四法宝可以计算Int。 print(1+1,1-1,1*1,1/1,sep=',') ''' 2,0,1,1 ''' Int一般用在输出数字的时候（虽然用Str也能达到，但使用Int可以更灵活），和计算数字的时候，有时在人机交互时，还可以把Int当做选项。如： print(1) ''' 1 ''' print(1-1+1) ''' 1 ''' print(input('>')) ''' >（输入：1） 1 ''' 2.2.字符串 +和*也可以运算字符串，嘿嘿嘿。 print('c'+'c') ''' cc ''' print('c'*2) ''' cc ''' 在这里有必要说说字符串怎么表示。 下面3个都是字符串的表示方法： '我是字符串，只能转义：\\'' \"我也是字符串，我可以输入:''\" ''' 我还是字符串， 可以换行， 还可以输入：'',\"\" ''' '不过，\\n我也能换行呀' # 输出： ''' 我是字符串，只能转义：' 我也是字符串，我可以输入:'' 我还是字符串， 可以换行， 还可以输入：'',\"\" 不过， 我也能换行呀 ''' 以上含有转义字符。我附上一张表，欢迎自查。 也就是'str'（单引号），\"str\"（双引号）和'''str'''（三引号）。 值得一提的是，Python好像是唯一支持单引号的编程语言了。 Str是最常用的数据类型。input()返回的就是Str。如： print(type('u')) ''' ''' 值得一提的是，type()可以检测类型。 2.3.布尔（Boolean，简称Bool） 布尔只有两种表现形式： True # 真 False # 假 布尔语句在判断中最常见了。 if True: print(1) else: print(2) ''' 1 ''' 2.3（番外） 在这里有必要提一下判断。 判断可是所有编程语言里都会带的玩意儿。在这里有必要学学。 判断的表现形式： if ONE_EXPRESSION: # 如果这个运算等于布尔值True，运行我。 elif ANOTHER_EXPRESSION: # elif可以省去。 # 如果这个运算等于布尔值True，运行我。 else: # else可以省去。 # 如果两个运算等于布尔值False，才运行我。 如： if 1>9: # 1大于9是绝对不可能的，所以不会运行下面已缩进的代码。 print(1) elif 1 以上代码中，1大于9和1小于0都不可能，所以会运行else下的代码。 值得一提的是，像1+1,3*3等，如果=后面的数字与运算结果一样，也会返回布尔值。 if 1+1=2: print(1) ''' 1 ''' 需要注意的是，在有elif的情况下，不能舍去else。 9.8更新：这段中=应该是==！！具体情况详见：Python学习笔记（6）——运算符 2.4.字典与列表 字典也算是很重要的知识点。 字典的表示方式如下： 我是一个字典 = {'一个名字':'一个值','另一个名字':'另一个值'} 名字是很重要的哦，一定要记清！ 接下来，再取值时要用“我是一个字典[我是一个名字]”。 如： 我是一个字典 = {'一个名字':'一个值','另一个名字':'另一个值'} print(我是一个字典['一个名字']) ''' 一个值 ''' 字典一般用来取值。如： name = {1:'小明',2:'小亮',3:'小红'} print(name[1]) ''' 小明 ''' 还有一个，那就是列表。 列表的表示方式如下： 我是一个列表 = [一个值,另一个值] 接下来，再取值时要用“我是一个列表[我是索引]”。 如： 我是一个列表 = [一个值,另一个值] print(我是一个列表[0]) ''' 一个值 ''' 在这里说一下，Python的索引是从0开始的。比如： 2.5.更酷的：类 类是自定义的类型。Python就是面向对象/类的编程。 类中可以有多种变量，在实例化后即可使用。 类的定义为： class ImClass: # 一堆东西...... ImClass就是一个类了。 前面说类中可以有多种变量。如： class Animal:# 定义动物类。 type = '一只动物' # 定义变量type。 值得一提的是，类的名字必须严格遵守骆驼命名法。请大家自行百度。 在实例化后（实例化方法：我是变量 = 我是类()），即可调用与赋值。拿前面的Animal（动物类）举例： 一只动物 = Animal() 一只动物.type = '动物' print(一只动物.type) ''' 动物 ''' 好啦，这就是本期的内容！ 散会~ ---------------- 下方文章为2021.8.29追加，上方为2021.8.28完成撰写 ---------------- 2.6.浮点数（Float） 浮点数就是像2.6,9.4,3.7这样的数。 虽然它也能用运算符四法宝，但总会有误差。如： >>> 0.1+0.2 0.30000000000000004 >>> 0.1+0.1-0.2 0.0 >>> 0.1+0.1+0.1-0.3 5.551115123125783e-17 >>> 0.1+0.1+0.1-0.2 0.10000000000000003 以上代码来自C语言中文网，原文链接：Python浮点数精度问题（包含解决方案） 那么只需要用Decimal就可完美解决。 在代码开头加上： from decimal import Decimal 就可以用\"Decimal('浮点数')\"转换后解决。如： a = Decimal('1.1') b = Decimal('2.8') c = Decimal('2.7') >>> float(a+b-c) ''' # 准确的 1.2 ''' >>> 1.1+2.8-2.7 ''' # 不准确的 1.1999999999999997 ''' 值得一提的是，float('浮点数')可以把字符串变成浮点数。其他也是这样：int()转为整数，str()转为字符串。 ---------------------------------------- 已经追加完毕 ---------------------------------------- "},"pylearning/basic/6.html":{"url":"pylearning/basic/6.html","title":"6.运算符","keywords":"","body":"Python学习笔记（6）——运算符 好几天没更文了，今天就再更新一篇吧，明天就开学了BB。 那么接下来就是诸葛亮本亮——哦不对，是kzx本x的教学时刻。 在上一篇中（上一篇详见：Python学习笔记（5）——类型）的时候，我埋下了一个世界最帅的帅b——哦不对又弄错了，是一个伏笔。 说运算符会在Python学习笔记（6）中出现。 没错，今天就是来教大家Python的运算符的。 1.运算符四法宝（算数运算符） 第一个当然是在Python学习笔记（5）中出现的运算符四法宝喽。 他们可以对数字进行运算。 对了，在上一篇中还说运算符四法宝可以对字符串进行运算。 >>> 1+1 2 >>> 3-2 1 >>> 2*2 4 >>> 4/2 2 不过，今天我发现，运算符并不是四法宝，居然是七法宝！ 因为我发现还有除整、取除数余、次方运算三个符号！！！ 所以今天我列出一张表给大家参考： 2.比较运算符（基本的） 比较运算符理解起来很简单，依旧列一张表： 这些运算符可使用于if中。 if 1 == 2: print(1) # 注意：这个代码块永远不会执行。 else: print(2) # 注意：这个代码块立马会执行。 好啦，这就是本期的内容。 温馨提示：布尔运算符这期就不讲啦。 散会~ 好啦，竟然你翻到这里了，就继续讲吧。 3.布尔运算符（逻辑运算符） 这个有必要好好讲讲，因为它也是if的重要部分。 3.1.非（not） 比如not y，如果它为假，就判断为真，反之，判断为假。 如： >>> not True False # 因为True不为假。 >>> not False True # 应为False为假。 3.2.与（and） 比如a and b，如果a和b都成立，那么判断为真，反之，判断为假。 如： >>> 1+1==2 and 1+2==2 False # 虽然1+1==2是对的，但1+2==2是不对的，所以返回True。 >>> 1+1==2 and 1+2==3 True # 1+1==2是对的，1+2==3也是对的，所以返回True。 3.3.或（or） 比如a or b，任意一个成立，就判断为真，反之，判断为假。 如： >>> 1+1==2 or 1+2==2 True # 1+1==2是对的，所以马上判断为真。 好啦，这就是本期的内容。 真·散会~真·散会~真·散会~（重要的事情说三遍） "},"pylearning/basic/7.html":{"url":"pylearning/basic/7.html","title":"7.如何把一个print(1)无限制下去，直到计算机吐血……","keywords":"","body":"Python学习笔记（7）——如何把一个print(1)无限制下去，直到计算机吐血…… Yes!今天是周日，我就再更新一篇文吧，明天又得干正事了BB。 如果没有看之前的，请翻回去瞅瞅，保准有惊喜。 那么接下来就是kzx本x的装逼时刻——哦不对，是教学时刻，欧耶~ 1.循环你知道吗，爷们 看我讲Python学习笔记（1）——迈出第一步的时候，有人可能问了： 我打印一个1，就得： print(1) 那么如果打印10000个1，就得这样： print(1) print(1) print(1) # 未完待续…… 那如果要打印100000000个1，那不是得叫爸爸了呀？！ 没有问题的啦。 我们会用到——循环~ 循环可以轻松做重复的动作。 比如我们刚才的问题，只需要： for i in range(100000000): print(1) 就可以轻松打印100000000个1啦。 自从接触到这玩意儿，每次遇到重复动作，就用循环，香的一批~ 2.那还等什么？开始呀？！ 好好好，开始开始开始……（加班继续写） 刚才我们用的是for循环，而待会儿我们还会用到while循环。 2.1.for循环 for循环的厉害大家都见过了吧。 for的格式如下： for VALUES in ITER_OBJECT: # ITER_OBJECT是要迭代的对象。 # 这里是要执行的代码…… 我们在Python学习笔记（5）——类型中遇到的所有序列式类型，比如列表、字典、字符串等等（除了数字），都可以作为ITER_OBJECT。 当ITER_OBJECT传入时，for就会遍历ITER_OBJECT，并把当前指针指向的元素赋值给VALUES，并开始执行代码块的内容。执行完成后，会让指针前进，并再次赋值VALUES，然后执行代码块的内容……直至指针无法前进，代码停止。 所以刚才，我们才轻松打印100000000个1。 刚才我们的演示动作相当于： VALUES = ITER_OBJECT[0] # 这里是要执行的代码…… VALUES = ITER_OBJECT[1] # 这里是要执行的代码…… VALUES = ITER_OBJECT[2] # 未完待续…… 那有小伙伴要问了，怎么从1打印到10000呢？ kzx：你不是已经看懂了吗？ 小伙伴：没有啊！！ kzx：难道我白讲了？！ 小伙伴：对呀~ kzx：日~还是重新讲吧 由于for会重复赋值给VALUES，所以可以这样写： for i in range(10000): print(i) ''' 0 1 2 3 4 5 6 7 8 9 # 未完待续…… ''' 效果不错吧。 小伙伴：不错是不错，可是怎么写呀？ （kzx直接来了一巴掌……） 对了，突然想起来，int无法进行遍历，需要使用range(int)进行。 2.2.while循环 那有的小伙伴也要问了：我怎么打印无数个1，直到电脑累死呢？ kzx：你可以用while。 小伙伴：那怎么写呢？ kzx：我把教程扔在宇宙空间站上了，去拿吧。（狗头） 开玩笑开玩笑，现在就教你。 while的格式如下： while EXPRESSION: # EXPRESION是判断条件。 # 这里是要执行的代码…… 当EXPRESSION传入时，while就会判断EXPRESSION是否成立，如果成立，就开始执行代码块里的内容，执行完成后判断EXPRESSION，继续执行代码块里的内容……直到EXPRESSION不再成立，或遇到break时，代码停止。 刚才的代码可以这么写： while True: print(1) 他就会把1打印到天荒地老，因为True是永远成立的。 这段代码就像下面这样： if True: print(1) if True: print(1) # 未完待续…… 是不是方便很多呢。 好了，这就是本期的内容！ 记得在评论区告诉我，你要用哪种方式来循环呢？for，while，还是屎（狗头）？ "},"pylearning/basic/8.html":{"url":"pylearning/basic/8.html","title":"8.把你的代码变短？可以可以，函数就行","keywords":"","body":"Python学习笔记（8）——把你的代码变短？可以可以，函数就行 今天我们继续来分享你的装x技巧，哦不对，是Python的学习教程。 如果没有看之前的，请翻回去瞅瞅，保准有惊喜。 现在正式开始传授于你Python学习方法，欧耶~ 1.节省代码，可以用什么 我们的文章标题就是“把你的代码变短”，那么谁能说一下怎么把代码变短呢？ 小伙伴：那还用问，当然是把重要的部分去掉，留下没个卵用的代码喽~ （kzx直接来了一巴掌……） 上期我们已经说了，用循环可以进行重复动作，这样可以节省代码。 那么如果要写这样一串乱七八糟、没个卵用、还无聊到天上的代码（以下简称“无聊的代码”）： # 代码块1 for i in range(100): print(1) # 代码块2 for i in range(100): print(1) # 代码块3 for i in range...... 好吧好吧，实在看不下去了。(¯¯╰╯∩╰╯￣) 那么在这种情况下，我们如何节省代码呢？ 可以可以，函数就行。 函数是一个执行重复动作的好帮手，只要定义一个函数，万行代码只需一行执行，是不是很牛掰呐~ 我们这个“无聊的代码”： # 代码块1 for i in range(100): print(1) # 代码块2 for i in range(100): print(1) # 代码块3 for i in range...... 只需要： def puts(): for i in range(100): print(1) # 代码块1 puts() # 代码块2 puts() # 代码块3 puts()...... 是不是很方便呢。 值得一提的是，Python还内置了函数，比如print()，input()，特别方便。 那么怎么编写函数呢？ 就不告诉你，你来打我呀~ 好了，这就是本期的内容！ 散会~ 好啦，竟然你翻到这里来了，就继续吧。 要知道，kzx是那种不讲情义的人吗~ 2.编写你的函数 在编写前，我们需要知道一个名词：DEF。 什么意思呢？ 它是Define的缩写，指定义一个函数。 说是Define，但我怎么感觉像Define function呢༼(￣╰╯￣)༽ 对了，在这里说一下，def是保留字，因此你不能写一个用def起名的变量哦~ 格式如下： def 我是一个函数(我是一个参数): # 我是一个代码块 接下来可以用我是一个函数(我是一个参数)来调用# 我是一个代码块。 添加我是一个参数的意思是，你可以让用户调用时传入一个变量，这样他让你撩几次妹，你就可以用for撩几次妹，欧耶~（不好意思，我又跑偏了） 另外，参数是不一定非得要，你也可以用for循环调用函数来撩妹，欧耶~（不好意思，我又又又跑偏了） 比如，我定义这么一个函数： def eat_rice(): print('kzx正在吃米……') 我就可以这么调用，让他吃3碗米： eat_rice() eat_rice() eat_rice() ''' kzx正在吃米…… kzx正在吃米…… kzx正在吃米…… ''' 那么如果你碰上大胃王，你可以： while True: eat_rice() 不好意思，我要被撑死了，嗝~嗝~嗝~嗝~嗝~嗝~嗝~嗝~嗝~嗝~嗝~嗝~嗝~嗝~（未完待续） 或者说你可以这么定义： def eat_rice(count): for i in range(count): print('kzx正在吃米……') 吃起来~ eat_rice(3) ''' kzx正在吃米…… kzx正在吃米…… kzx正在吃米…… ''' 这样不就很简单啦。 好啦，今天的文章就到这里！ 欢迎发挥想象力，来一个eat_chicken()~（不好意思，我又双叒叕跑偏了。怎么扯到吃鸡游戏上了~） "},"pylearning/basic/9.html":{"url":"pylearning/basic/9.html","title":"9.万事万物皆对象","keywords":"","body":"Python学习笔记（9）——万事万物皆对象 在开始之前，请允许我来个搞笑图片： 小伙伴：是的，不知道怎么写。(lll￢ω￢) 的确，因为Python的可能性太大了，有千万名开发者在维护Python，也有人在编写Python的模块，说不定何时给你来了个生孩子的模块呢。（狗头保命(⊃･ᴥ･)つ） 竟然刚才说到class了，那就给你讲讲类吧。 虽然之前讲了，但是乱七八糟的，TMD都没讲对。 小伙伴：我就知道肯定得学习。(⊃･ᴥ･)つ 1.在Python中，你看到的都是什么 在Python学习笔记（5）——类型中，我们认识了许多类型。可你知道这些都是什么吗？ 前面说type()可以检测类型。 我在IPython中检测了几个类型： ？？？ WTMD怎么跟类的输出一样啊？！ 可以看到，这意思是：什么str、int、bool、list这些都是类啊！！ 这下大家知道本文开头是什么意思了吧？在Python中，万事万物都是类。 其实Python2还没这样呢，检测出来的还是，而在Python3中，妥妥的变成类，了。 那么怎么编写类呢？ 就不告诉你，你来打我呀~ 好啦，这就是本期的内容！ 散会~ 好啦，竟然你翻到这里来了，就继续吧。 要知道，kzx是那种不讲情义的人吗~ 2.编写你的类 我们之前已经讲过类的格式了。 我们今天主要讲怎么嵌入函数，让它活生生变成append一样的函数。 对了，需要说一个知识点。 2.1.Self是什么鬼 在嵌入函数时，必须加上一个参数：self。 停停！self？什么鬼？ 你知道这是什么吗？ 大家三年级肯定英语课学过，那啥Myself之类的吧？ 这个课不是有self吗？介绍自己的吗？ 所以self就是自己的意思。 你可以创造一个__init__函数，来给self分配几个变量，这样整个类都可以使用。 对了，self这个函数，在实例化之后，可以不用填写。 好，接下来我们来看一下，嵌入函数的格式吧： class 一个类: def 一个函数(self): # 一个代码块…… 当# 一个代码块……写好之后，就可以轻松执行： 一个类的实例化 = 一个类() 一个类的实例化.一个函数() 比如： class Food: def rice(self): print('我是一粒米') 调用“一粒米”的示例： fooder = Food() fooder.rice() ''' 我是一粒米 ''' 是不是很简单呢。 好啦，今天的文章就到这里！ 欢迎来做一个有趣的东西，比如说Man()~ "},"pylearning/basic/10.html":{"url":"pylearning/basic/10.html","title":"10.我的爸爸的爸爸的爸爸的爸爸……","keywords":"","body":"Python学习笔记（10）——我的爸爸的爸爸的爸爸的爸爸…… 开始之前，我们问个问题（以下简称为无聊的问题）： 你的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸叫什么？ 你别说答出来了，能把这个问题一字不差的读完，也是…… 有些人看到这儿就默默地走开了……等一下啊，我们今天不是让你看这的喂！！！！ 我们来让你学继承的呀！！！ 小伙伴：我就知道肯定得学习。（转过头来） 1.继承是什么？ 刚才说了一个继承，那继承是什么呢？ 我们还得回到无聊的问题上： 你的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸叫什么？ 其中这个关系：你的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸，祖祖代代相当于：爸爸、爷爷、曾祖父、高祖父…… 那么、相当于：曾祖父继承高祖父、爷爷继承曾祖父、爸爸继承爷爷…… 那么……现在你知道了吧？继承 相当于下一代。 那么，我们将把它运用到类中，让一个类拥有另一个类的特性。 2.类的继承 类的继承为： class SonClass(FatherClass): #SonClass是子类，FatherClass是父类。 # 子类的内容 比如我们做一个测试：用子类访问父类的变量。 >>> class FatherClass: ... fam_name = '宋' ... >>> class SonClass(FatherClass): ... pass ... >>> SonClass().fam_name '宋' 大家可以试一试，绝对是真的！ 这是我在IPython的实验： 函数也可以： >>> class FatherClass: ... def my(self): ... print('我是宋公子！') ... >>> class SonClass(FatherClass): ... pass ... >>> SonClass().my() 我是宋公子！ 测试： 这个宋公子，怎么样，它祖孙三代都叫宋公子~ >>> class GrandpaClass: ... name = '宋公子' ... >>> class FatherClass(GrandpaClass): ... pass ... >>> class SonClass(FatherClass): ... pass ... >>> SonClass().name '宋公子' 测试： 怎么样，是不是很香呢。 好啦，今天的文章就到这里！ 最后来思考：我们这个无聊的问题： 你的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸的爸爸叫什么？ 用Python怎么表示？ "},"pylearning/basic/11.html":{"url":"pylearning/basic/11.html","title":"11.A的爸爸，B的爸爸","keywords":"","body":"Python学习笔记（11）——A的爸爸，B的爸爸 开始之前，问你一个沙雕的问题： 如果你是老陈的爸爸、老王的爸爸、老李的爸爸、老钱的爸爸、老周的爸爸，那么请问你是谁的儿子？ 小伙伴：答，我谁也不是。(⊃･ᴥ･)つ 哈哈哈，是不是被整蒙啦，但今天可不是让他们继承你哈~ 这次是来带你走进多继承的。 1.用“老赵”认识多继承 如果你有三个孩子，他们分别各自为家，那么关系图就像下面这样： 哈哈哈，请原谅我的联系线。---(∩┌┐∩)--- 那么就可以说，赵小聪是赵小静和赵小白的儿子。（为什么呢，-因-为-出-轨-了-呗-~-（假装删除线）） 假如说刚才加的那个删除线是真事，那么这就叫多继承。 现在呢，听懂了吧。 多继承就是两个妈妈的孩子。多个父对象的子对象。 2.那么如何多继承呢？ 很简单，格式如下： class OneFather: pass class TwoFather: pass class Son(OneFather,TwoFather): pass 比如刚才那个，用代码演示为： >>> class ZhaoXiaoJing: ... one_type = '赵小静的女儿' ... >>> class ZhaoXiaoBai: ... two_type = '赵小月的女儿' ... >>> class ZhaoXiaoCong(ZhaoXiaoJing,ZhaoXiaoYue): ... pass ... >>> smart = ZhaoXiaoCong() >>> smart.one_type '赵小静的女儿' >>> smart.two_type '赵小月的女儿' 是不是很简单呢。 hei brother,这么简单我还发文干啥呀，接下来好戏还有更多呢。 3.钻石一样的恶心问题 接下来，我们来看看另一种多继承，称为钻石继承。（这段代码简称为恶心多继承） class Grandpa: call_grand = 0 def call(self): self.call_grand += 1 print('Grandpa called') class Father1(Grandpa): call_fa1 = 0 def call(self): Grandpa.call(self) self.call_fa1 += 1 print('Father1 called') class Father2(Grandpa): call_fa2 = 0 def call(self): Grandpa.call(self) self.call_fa2 += 1 print('Father2 called') class Son(Father1,Father2): call_son = 0 def call(self): Father1.call(self) Father2.call(self) self.call_son += 1 print('Son called') if __name__ == '__main__': son = Son() son.call() print([son.call_grand,son.call_fa1,son.call_fa2,son.call_son]) 需要注意的是，这段代码里的+= 1与C中的++效果一样。 结构像这样： 我们想它应该这样运行： Grandpa called Father1 called Father2 called Son called [1, 1, 1, 1] 但他妈的跑成这样了： ？？？ 怎么跑成两次了？？？ 玩呢？？？！！！ 骇，这他妈怎么回事，我不玩了。 好啦，这就是本期的内容！ 散会~ （咳咳咳，这个表情包用几次了？？） 好啦，竟然你翻到这里来了，就继续吧。 要知道，kzx是那种不讲情义的人吗~ 3.1.MRO是什么鬼 要想开始，我们需要了解一个知识点：Method resolution order，简称MRO 。 ？？？ MRO？？？什么鬼？？？ 等一下，我来翻译一下：方法解析顺序。 MRO会在此方法左右干找找不到时，向前搜它的父亲、爷爷、曾祖、高祖……直至鼻祖（Python3默认会给所有的类增加一个父类，名为object，尤其表现在最前端的父类上，这就是新式类。而旧式类不会添加object）。 一般情况下，这个顺序有好多种情况： 从子类向前搜索。这种情况很简单，是单继承搜索方法，如：C->B->A。 搜索子类的第一个父类，如果没有，则搜索父类的父类，直到搜索到最前端的父类（不包括object），开始照样搜索第二个父类，直到所有父类全部搜索完，如：C->B->Base->A->Base。这种方式为Depth first search（DFS，深度优先搜索） 。 使用DFS全部搜索，然后保留重复类中最后的类，如：C->B->A->Base。这种方法属于新式类。 使用merge()为搜索顺序排序。这种方式为C3，是至今唯一一个留存住的方式。 接下来，我们主要讲解C3的顺序。 3.2.C3？？？merge()？？？ 很多人看到C3与merge()，都是一脸懵逼。 哈哈哈，别那么懵逼呀，我还没讲呢。(⊃･ᴥ･)つ 我们的C3公式，可记为：L[CLASS] = [CLASS] + merge(L(1),L[2],L[3],……,[1],[2],[3],……)。 而计算出MRO顺序，可以： L[类] = [类] + merge(L[1],L[2],……,[1],[2],……) L[类] = [类] + merge([1,1和2共同的父类],[2,1和2共同的父类],[1和2共同的父类,object],[1,2]) L[类] = [类,1] + merge([1和2共同的父类],[2,1和2共同的父类],[1和2共同的父类,object],[2]) L[类] = [类,1,2] + merge([1和2共同的父类],[1和2共同的父类],[1和2共同的父类,object]) L[类] = [类,1,2,1和2共同的父类] + merge([object]) L[类] = [类,1,2,1和2共同的父类,object] 需要注意的是，3-6步从前往后，先查找merge的第一个列表的第一个值有没有重复类，如果有，将它全舍去，将第一个[类]添加上这个值，以此类推，直到推出object即可。 假如C父类为A和B，就可以这么计算： L[C] = [C] + merge(L[A],L[B],[A],[B]) = [C] + merge([A,object],[B,A],[A,B]) = [C,A] + merge([object],[B],[B]) = [C,A,B] + merge([object]) = [C,A,B,object] 最后得出顺序为[C,A,B,object]。 我们可以验证一下，比如用Python的魔法函数__mro__，可以得出顺序： 怎么样。 而我们刚才那个恶心多继承，我们可以计算一下Son类的mro顺序： L[Son] = [Son] + merge(L[Father1],L[Father2],[Father1],[Father2]) = [Son] + merge([Father1,Grandpa],[Father2,Grandpa],[Grandpa,object],[Father1,Father2]) = [Son,Father1] + merge([Grandpa],[Father2,Grandpa],[object],[Father2]) = [Son,Father1,Father2] + merge([Grandpa],[object],[Grandpa]) = [Son,Father1,Father2,Grandpa] + merge([object]) = [Son,Father1,Father2,Grandpa,object] 验证： 现在知道了吧，它先执行Father1，再执行Father2，而它们俩都调用了Grandpa，就会调用两次。 我们也得出了真理：男人永远不会生孩子。object永远是最后。 那么如何让它只调用一次呢？ super()可能是个好办法。 3.3.super()永远的神 super其实是个类，但它会继承你的父类方法。格式如下： super().一个函数() 我们来试一试，把恶心多继承的代码改成： class Grandpa: call_grand = 0 def call(self): self.call_grand += 1 print('Grandpa called') class Father1(Grandpa): call_fa1 = 0 def call(self): #Grandpa.call(self) super().call() self.call_fa1 += 1 print('Father1 called') class Father2(Grandpa): call_fa2 = 0 def call(self): #Grandpa.call(self) super().call() self.call_fa2 += 1 print('Father2 called') class Son(Father1,Father2): call_son = 0 def call(self): ''' Father1.call(self) Father2.call(self) ''' super().call() self.call_son += 1 print('Son called') if __name__ == '__main__': son = Son() son.call() print([son.call_grand,son.call_fa1,son.call_fa2,son.call_son]) 跑起来： 是不是很神奇，它把两次的super().call()合并起来了。 诶呦！这期严重超长了。 这就是本期的内容！ 散会~ "},"pylearning/basic/12.html":{"url":"pylearning/basic/12.html","title":"12.嘿嘿嘿，拿来吧你","keywords":"","body":"Python学习笔记（12）——嘿嘿嘿，拿来吧你 开始之前，来个问题： 你喜欢自己造轮子，还是装别人的轮子？ 小伙伴：当然是装别人的轮子喽。(⊃･ᴥ･)つ 但是，Python岂不是不能用？ 不对哦，不仅能用，还能用出花样。 这才叫“人生苦短，我用Python”呢。 1.模块懂不懂？ 我们需要知道一个概念：模块。 模块其实很简单。 我们来写一个文件，命名为Module.py吧： 是的，你没看错，他就是一个模块。 小伙伴：那么模块的用处不就是“一劳永逸”吗？我怎么没看出一点呢？ 别急，等会儿你就见识到了。 2.模块与Import 我们来认识一下Import这个单词吧，他有导入，输入，引进的意思，所以用来导入模块。 格式如下： import 我是一个模块 而使用函数与类的格式如下： Module.函数() class_ = Module.类() # 使用规范是Module.想调用的。 你知道我们刚才的Module.py的模块名是什么吗？ 很简单，文件名中.py 去掉就行了。 所以我们的模块名是Module。 需要注意的是，给模块取名时建议小写。 现在我们来试试，在Module.py中输入： #Filename:Module.py def hellowa(): print('你好哇~') 在B.py中输入： #filename:B.py import Module Module.hellowa() 运行： 是不是很神奇，Module.py中的hellowa()被引用过来了。 还有呢，Python自带了sys，time等神奇的模块，让你一行调用，享受便捷。 这还不够神奇呢。 3.PyPI I love you 有一个神奇的网站叫PyPI（Python Package Index） ，它是Python开发的，全世界有数万人在这里发布他们的模块。 可以看到，截至发文时（2021.9.24），PyPI发布了近32万个项目。 在这里，你可以搜索到你想要的模块，然后一键安装。 等！安装？ 难道像C那样拷贝给D:/Program Files/MinGW_64/……个没完吗？ 当然不是，我们有PIP呢。 3.1.PIP yyds PIP（Python install package）可以便捷的安装模块，从pypi里搜查。 只需要： ...> pip install 一个模块 就行啦。 比如说我在查询代理抓包的模块，于是搜索代理（Proxy），发现了这个： 呼声挺高的。 我搜完了攻略（对，搜攻略是真实写照(⊃･ᴥ･)つ），开始一顿操作猛如虎，pip install mitmproxy后，我就开始开心玩耍了。 长时间下来，你可以pip freeze来看一下你的所有模块。 我的是这样： altgraph==0.17 appdirs==1.4.4 argon2-cffi==20.1.0 asgiref==3.4.1 async-generator==1.10 attrs==21.2.0 Automat==20.2.0 autopep8==1.5.7 backcall==0.2.0 backports.entry-points-selectable==1.1.0 beautifulsoup4==4.9.3 bleach==4.0.0 blinker==1.4 Brotli==1.0.9 cachetools==4.2.2 certifi==2020.12.5 cffi==1.14.5 chardet==4.0.0 cheroot==8.5.2 click==8.0.1 colorama==0.4.4 constantly==15.1.0 cryptography==3.4.7 cssselect==1.1.0 cycler==0.10.0 debugpy==1.4.1 decorator==5.0.9 defusedxml==0.7.1 distlib==0.3.2 Django==3.2.6 dominate==2.6.0 easygui==0.96 entrypoints==0.3 filelock==3.0.12 Flask==2.0.1 Flask-Bootstrap==3.3.7.1 future==0.18.2 gevent==21.1.2 greenlet==1.1.0 h11==0.12.0 h2==4.0.0 hashids==1.3.1 hpack==4.0.0 hyperframe==6.0.1 hyperlink==21.0.0 idna==2.10 imageio==2.9.0 incremental==21.3.0 ipykernel==6.1.0 ipython==7.26.0 ipython-genutils==0.2.0 ipywidgets==7.6.3 itemadapter==0.3.0 itemloaders==1.0.4 itsdangerous==2.0.1 jaraco.functools==3.3.0 jedi==0.18.0 Jinja2==3.0.1 jmespath==0.10.0 jsonschema==3.2.0 jupyter==1.0.0 jupyter-client==6.1.12 jupyter-console==6.4.0 jupyter-core==4.7.1 jupyterlab-pygments==0.1.2 jupyterlab-widgets==1.0.0 kaitaistruct==0.9 kiwisolver==1.3.2 ldap3==2.9.1 lxml==4.6.3 MarkupSafe==2.0.1 matplotlib==3.4.3 matplotlib-inline==0.1.2 mimesis==4.1.3 mistune==0.8.4 mitmproxy==7.0.2 more-itertools==8.8.0 MouseInfo==0.1.3 msgpack==1.0.2 MyQR==2.3.1 nbclient==0.5.3 nbconvert==6.1.0 nbformat==5.1.3 nest-asyncio==1.5.1 notebook==6.4.3 numpy==1.21.0 opencv-python==4.5.3.56 packaging==21.0 pandas==1.3.1 pandocfilters==1.4.3 parsel==1.6.0 parso==0.8.2 passlib==1.7.4 pefile==2021.5.24 pickleshare==0.7.5 Pillow==8.3.0 platformdirs==2.2.0 priority==1.3.0 progress==1.6 progressbar==2.5 prometheus-client==0.11.0 prompt-toolkit==3.0.19 Protego==0.1.16 protobuf==3.17.3 publicsuffix2==2.20191221 py2exe==0.10.4.0 pyasn1==0.4.8 pyasn1-modules==0.2.8 PyAutoGUI==0.9.53 pycodestyle==2.7.0 pycparser==2.20 PyDispatcher==2.0.5 pydivert==2.1.0 pyee==8.1.0 pygame==2.0.1 PyGetWindow==0.0.9 Pygments==2.9.0 pyinstaller==4.3 pyinstaller-hooks-contrib==2021.2 pymongo==3.12.0 PyMsgBox==1.0.9 pyOpenSSL==20.0.1 pyparsing==2.4.7 pyperclip==1.8.2 pyppeteer==0.2.5 PyQt5==5.15.4 pyqt5-plugins==5.15.4.2.2 PyQt5-Qt5==5.15.2 PyQt5-sip==12.9.0 pyqt5-tools==5.15.4.3.2 PyRect==0.1.4 pyrsistent==0.18.0 PyScreeze==0.1.27 python-dateutil==2.8.2 python-dotenv==0.18.0 PyTweening==1.0.3 pytz==2021.1 pywin32==301 pywin32-ctypes==0.2.0 pywinpty==0.5.7 pyzmq==22.2.1 qt5-applications==5.15.2.2.2 qt5-tools==5.15.2.1.2 qtconsole==5.1.1 QtPy==1.9.0 queuelib==1.6.1 redis==3.5.3 requests==2.25.1 ruamel.yaml==0.17.10 ruamel.yaml.clib==0.2.6 schedule==1.1.0 Scrapy==2.5.0 Send2Trash==1.8.0 service-identity==21.1.0 six==1.16.0 sortedcontainers==2.4.0 soupsieve==2.2.1 sqlparse==0.4.1 termcolor==1.1.0 terminado==0.9.5 testpath==0.5.0 toml==0.10.2 tornado==6.1 tqdm==4.62.0 traitlets==5.0.5 Twisted==21.7.0 twisted-iocpsupport==1.0.1 typing-extensions==3.10.0.0 urllib3==1.26.4 urwid==2.1.2 virtualenv==20.7.2 visitor==0.1.3 w3lib==1.22.0 wcwidth==0.2.5 web.py==0.62 webencodings==0.5.1 websockets==8.1 Werkzeug==2.0.1 widgetsnbextension==3.5.1 wsproto==1.0.0 wxPython==4.1.1 xlrd==2.0.1 xlwt==1.3.0 yaspin==2.1.0 you-get==0.4.1527 zope.event==4.5.0 zope.interface==5.4.0 zstandard==0.15.2 真是够有成就感呀。(⊃･ᴥ･)つ 好了，今天的文章就到这里！ 欢迎来编写一个模块哟~ "}}